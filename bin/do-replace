#!/usr/bin/env python3
#
# do-replace [OPTIONS] OLD NEW [FILE...]
#
# Global replace of OLD with NEW in the given files.

import argparse
import os
import re
import shutil
import sys

SKIP_DIRS = {".git", ".svn", ".hg", "node_modules", "__pycache__", ".venv", "venv"}

USAGE = """\
Usage: do-replace [OPTIONS] OLD NEW [FILE...]

Global replace of OLD with NEW in the given files.

Options:
  -d, --dry          Dry run (show what would change without modifying)
  -r, --regex        Treat OLD as a regular expression
  -i, --ignore-case  Case-insensitive matching
  -I, --interactive  Prompt before each file modification
  -R, --recursive    Recursively search directories
  -b, --backup       Create .bak backup files before modifying
  -h, --help         Show this help message

Examples:
  do-replace 'foo' 'bar' *.txt
  do-replace -d 'old_func' 'new_func' src/*.py
  do-replace -r 'log\\.debug' 'log.info' **/*.py
  do-replace -ri 'todo:?' 'FIXME' *.md
  do-replace -R 'oldapi' 'newapi' src/
  do-replace -b 'risky' 'safe' config.ini
"""


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Global replace of OLD with NEW in the given files.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage=USAGE,
        add_help=True,
    )
    parser.add_argument(
        "-d", "--dry", action="store_true", help="Dry run (show what would change)"
    )
    parser.add_argument(
        "-r", "--regex", action="store_true", help="Treat OLD as a regular expression"
    )
    parser.add_argument(
        "-i", "--ignore-case", action="store_true", help="Case-insensitive matching"
    )
    parser.add_argument(
        "-I",
        "--interactive",
        action="store_true",
        help="Prompt before each file modification",
    )
    parser.add_argument(
        "-R", "--recursive", action="store_true", help="Recursively search directories"
    )
    parser.add_argument(
        "-b", "--backup", action="store_true", help="Create .bak backup files"
    )
    parser.add_argument("old", metavar="OLD", help="Text or pattern to search for")
    parser.add_argument("new", metavar="NEW", help="Replacement text")
    parser.add_argument(
        "files", metavar="FILE", nargs="*", default=["."], help="Files or directories"
    )

    return parser.parse_args()


def is_binary(path, sample_size=8192):
    """Check if file appears to be binary by looking for null bytes."""
    try:
        with open(path, "rb") as f:
            chunk = f.read(sample_size)
            return b"\x00" in chunk
    except (IOError, OSError):
        return True


def is_hidden(name):
    """Check if a file or directory name is hidden (starts with dot)."""
    return name.startswith(".")


def collect_files(paths, recursive=False):
    """Expand paths, handle recursion, yield file paths."""
    for path in paths:
        if os.path.isfile(path):
            yield path
        elif os.path.isdir(path):
            if recursive:
                for root, dirs, files in os.walk(path):
                    # Filter out hidden and skipped directories in-place
                    dirs[:] = [
                        d for d in dirs if not is_hidden(d) and d not in SKIP_DIRS
                    ]
                    for filename in files:
                        if not is_hidden(filename):
                            yield os.path.join(root, filename)
            else:
                # Non-recursive: just warn that it's a directory
                sys.stderr.write(
                    f"[!] Skipping directory (use -R for recursive): {path}\n"
                )
        elif not os.path.exists(path):
            sys.stderr.write(f"[!] File not found: {path}\n")


def count_matches(text, pattern, use_regex=False, ignore_case=False):
    """Count occurrences of pattern in text."""
    if use_regex:
        flags = re.IGNORECASE if ignore_case else 0
        return len(re.findall(pattern, text, flags))
    else:
        if ignore_case:
            return text.lower().count(pattern.lower())
        return text.count(pattern)


def do_replace(text, pattern, replacement, use_regex=False, ignore_case=False):
    """Replace pattern in text, return new text."""
    if use_regex:
        flags = re.IGNORECASE if ignore_case else 0
        return re.sub(pattern, replacement, text, flags=flags)
    else:
        if ignore_case:
            # Case-insensitive string replacement
            regex = re.compile(re.escape(pattern), re.IGNORECASE)
            return regex.sub(replacement, text)
        return text.replace(pattern, replacement)


def replace_in_file(
    path,
    pattern,
    replacement,
    use_regex=False,
    ignore_case=False,
    dry_run=False,
    backup=False,
    interactive=False,
):
    """Replace pattern in file, return count of replacements.

    Returns:
        int: Number of replacements made (or that would be made in dry-run)
        -1: Error occurred
        -2: User skipped (interactive mode)
    """
    # Skip binary files
    if is_binary(path):
        return 0

    # Read file
    try:
        with open(path, "r", encoding="utf-8") as f:
            text = f.read()
    except UnicodeDecodeError:
        # Likely a binary file that slipped through
        return 0
    except (IOError, OSError) as e:
        sys.stderr.write(f"[!] Error reading {path}: {e}\n")
        return -1

    # Count matches
    count = count_matches(text, pattern, use_regex, ignore_case)
    if count == 0:
        return 0

    # Interactive mode: prompt user
    if interactive and not dry_run:
        try:
            response = input(f"Replace {count} occurrence(s) in {path}? [y/N] ")
            if response.lower() not in ("y", "yes"):
                return -2
        except (EOFError, KeyboardInterrupt):
            print()
            return -2

    # Dry run: just report
    if dry_run:
        print(f"{path:<50} [{count:>3}] (dry run)")
        return count

    # Create backup if requested
    if backup:
        backup_path = path + ".bak"
        try:
            shutil.copy2(path, backup_path)
        except (IOError, OSError) as e:
            sys.stderr.write(f"[!] Error creating backup {backup_path}: {e}\n")
            return -1

    # Perform replacement
    new_text = do_replace(text, pattern, replacement, use_regex, ignore_case)

    # Write file
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(new_text)
    except (IOError, OSError) as e:
        sys.stderr.write(f"[!] Error writing {path}: {e}\n")
        return -1

    print(f"{path:<50} [{count:>3}]")
    return count


def main():
    """Main entry point."""
    args = parse_args()

    # Validate regex pattern if needed
    if args.regex:
        try:
            re.compile(args.old)
        except re.error as e:
            sys.stderr.write(f"[!] Invalid regex pattern: {e}\n")
            sys.exit(2)

    total = 0
    errors = 0
    skipped = 0

    for path in collect_files(args.files, args.recursive):
        result = replace_in_file(
            path,
            args.old,
            args.new,
            use_regex=args.regex,
            ignore_case=args.ignore_case,
            dry_run=args.dry,
            backup=args.backup,
            interactive=args.interactive,
        )
        if result == -1:
            errors += 1
        elif result == -2:
            skipped += 1
        else:
            total += result

    # Report results
    if total == 0 and errors == 0 and skipped == 0:
        sys.stderr.write(f"No match for: {args.old}\n")
        sys.exit(1)
    elif errors > 0:
        sys.exit(2)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()

# EOF - vim: ts=4 sw=4 noet
